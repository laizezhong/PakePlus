{"name":"Qiyukf","url":"https://ybzfyxgs5.qiyukf.com/chat/","showName":"Qiyukf","appid":"com.Qiyukf.app","icon":"","iconRound":true,"state":true,"single":true,"injectJq":true,"tauriApi":false,"devbug":false,"version":"0.0.1","preview":"desktop","platform":["1-1","1-2","2-1","2-2"],"width":800,"height":600,"desc":"","jsFile":[],"filterCss":"","customJs":"// 群聊消息分析插件\n(function() {\n    'use strict';\n    \n    // 插件配置\n    const PLUGIN_CONFIG = {\n        // API配置\n        api: {\n            baseUrl: 'https://techagent.yeepay.com',  // API基础地址\n            endpoint: '/chatbot/get_answer',           // API端点\n            clickUsageEndpoint: '/chatbot/click_answer',  // 点击使用量收集API端点\n            token: 'Bearer app-bb0PO2n760j0Fxgj3mqCNFVm'  // 认证令牌\n        },\n        \n        // URL匹配规则（可在这里配置需要激活插件的页面）\n        urlPatterns: [\n            /qiyukf\\.com\\/chat\\/\\?id=\\d+/i,         // 七鱼客服系统\n        ],\n        \n        // 消息选择器配置\n        messageSelectors: {\n            messageItem: '.msg',                    // 消息容器\n            messageContent: 'span[data-test=\"content\"]',  // 消息内容\n            senderName: 'span[data-test=\"name\"]',   // 发送人名称  \n            messageTime: 'span[data-test=\"time\"]',  // 消息时间\n            groupName: '.nick',                      // 群聊/用户名称\n            popTrigger: '.msg-bubble'                 // 悬浮触发区域 msg-main、msg-bubble\n        },\n        \n        debug: true // 是否打印调试日志，直接写死为true\n    };\n    \n    // 日志输出工具函数\n    function pluginLog(...args) {\n        if (PLUGIN_CONFIG.debug) {\n            console.log('[群聊插件]', ...args);\n        }\n    }\n    function pluginError(...args) {\n        if (PLUGIN_CONFIG.debug) {\n            console.error('[群聊插件]', ...args);\n        }\n    }\n    function pluginWarn(...args) {\n        if (PLUGIN_CONFIG.debug) {\n            console.warn('[群聊插件]', ...args);\n        }\n    }\n    \n    // 检查当前页面是否需要激活插件\n    function shouldActivatePlugin() {\n        const currentUrl = window.location.href;\n        return PLUGIN_CONFIG.urlPatterns.some(pattern => pattern.test(currentUrl));\n    }\n    \n    // 初始化插件\n    function initPlugin() {\n        if (!shouldActivatePlugin()) {\n            pluginLog('当前页面不匹配，插件未激活');\n            return;\n        }\n        \n        pluginLog('插件已激活在页面:', window.location.href);\n        \n        // 监听消息悬停事件\n        setupMessageHoverListener();\n    }\n    \n    // 全局变量保存消息点击监听器\n    let onMessageClickHandler = null;\n\n    // 设置消息悬停监听器\n    function setupMessageHoverListener() {\n        if (onMessageClickHandler) return; // 防止重复绑定\n        \n        /**\n         * 鼠标悬停进入处理\n         * 只在鼠标进入.msg-bubble最外层时触发，避免因子元素冒泡导致的按钮闪现\n         */\n        const handleMouseEnter = function(event) {\n            // 修复：只有Element类型才可用closest\n            if (!(event.target instanceof Element)) return;\n            // 只处理鼠标进入.msg-bubble最外层的情况\n            const popTrigger = event.target.closest(PLUGIN_CONFIG.messageSelectors.popTrigger);\n            if (!popTrigger || event.target !== popTrigger) return;\n            // 找到对应的消息容器元素\n            let messageElement = popTrigger.closest(PLUGIN_CONFIG.messageSelectors.messageItem);\n            if (!messageElement) return;\n            // 排除系统消息、分割线、历史提示等类型消息\n            if (\n                messageElement.classList.contains('msg-sys') ||\n                messageElement.classList.contains('msg-splitLine') ||\n                messageElement.classList.contains('m-msgsplit') ||\n                messageElement.classList.contains('msg-cnotify') ||\n                messageElement.classList.contains('msg-ainvalid') ||\n                messageElement.classList.contains('msg-right') // 新增：排除右侧消息\n            ) {\n                return;\n            }\n            // 不再检查当前消息是否已有悬浮窗，因为我们会在创建前移除所有悬浮窗\n            // 检查消息内容是否为空\n            let hasContent = false;\n            // 1. 检查主要内容选择器\n            const contentElement = messageElement.querySelector(PLUGIN_CONFIG.messageSelectors.messageContent);\n            if (contentElement && contentElement.textContent.trim()) {\n                hasContent = true;\n            }\n            // 1.5 检查图片内容\n            if (!hasContent) {\n                const imageElement = messageElement.querySelector('img.m-message-image_pic');\n                if (imageElement && imageElement.src) {\n                    hasContent = true;\n                }\n            }\n            // 2. 检查气泡内文本\n            if (!hasContent) {\n                const popTrigger = messageElement.querySelector(PLUGIN_CONFIG.messageSelectors.popTrigger);\n                if (popTrigger) {\n                    const timeElement = popTrigger.querySelector('.time');\n                    let bubbleText = popTrigger.textContent.trim();\n                    if (timeElement) {\n                        bubbleText = bubbleText.replace(timeElement.textContent.trim(), '').trim();\n                    }\n                    if (bubbleText) {\n                        hasContent = true;\n                    }\n                }\n            }\n            // 3. 检查富文本内容\n            if (!hasContent) {\n                const richContent = messageElement.querySelector('.m-cnt');\n                if (richContent && richContent.textContent.trim()) {\n                    hasContent = true;\n                }\n            }\n            // 4. 检查系统消息内容（但系统消息不显示AI按钮）\n            if (!hasContent) {\n                if (messageElement.classList.contains('msg-sys')) {\n                    const bubbleText = messageElement.querySelector('.msg-bubble');\n                    if (bubbleText && bubbleText.textContent.trim()) {\n                        hasContent = true;\n                    }\n                }\n            }\n            if (!hasContent) return;\n            // 创建悬浮内容\n            createFloatingContent(messageElement);\n        };\n        \n        /**\n         * 鼠标悬停离开处理\n         * 只在鼠标离开.msg-bubble最外层时触发，避免因子元素冒泡导致的按钮误移除\n         */\n        const handleMouseLeave = function(event) {\n            // 修复：只有Element类型才可用closest\n            if (!(event.target instanceof Element)) return;\n            // 只处理鼠标离开.msg-bubble最外层的情况\n            const msgBubble = event.target.closest('.msg-bubble');\n            if (!msgBubble || event.target !== msgBubble) return;\n            // 找到对应的消息容器元素\n            let messageElement = msgBubble.closest(PLUGIN_CONFIG.messageSelectors.messageItem);\n            if (!messageElement) return;\n            // 判断鼠标是否还在当前msg-bubble内（如在悬浮内容上等），还在则不移除\n            if (msgBubble && event.relatedTarget && msgBubble.contains(event.relatedTarget)) {\n                return;\n            }\n            // 延迟移除悬浮内容，避免鼠标移动到悬浮内容上时立即消失\n            setTimeout(() => {\n                const floatingContent = messageElement.querySelector('.ai-floating-content');\n                if (floatingContent && !floatingContent.matches(':hover')) {\n                    floatingContent.remove();\n                }\n            }, 200);\n        };\n        \n        // 添加事件监听 - 使用事件委托，监听整个文档\n        document.addEventListener('mouseenter', handleMouseEnter, true);\n        document.addEventListener('mouseleave', handleMouseLeave, true);\n        \n        // 额外监听消息容器的鼠标事件，确保整个消息区域都能触发\n        const chatContainer = document.querySelector('#chat-view');\n        if (chatContainer) {\n            chatContainer.addEventListener('mouseenter', handleMouseEnter, true);\n            chatContainer.addEventListener('mouseleave', handleMouseLeave, true);\n        }\n        \n        // 保存处理器引用以便后续移除\n        onMessageClickHandler = { handleMouseEnter, handleMouseLeave };\n        \n        pluginLog('已添加消息悬停监听（仅右侧消息）');\n    }\n\n    /**\n     * 移除页面上所有的悬浮窗\n     */\n    function removeAllFloatingContents() {\n        const allFloatingContents = document.querySelectorAll('.ai-floating-content');\n        allFloatingContents.forEach(content => {\n            content.remove();\n        });\n        if (allFloatingContents.length > 0) {\n            pluginLog(`已移除 ${allFloatingContents.length} 个悬浮窗`);\n        }\n    }\n    \n    /**\n     * 创建悬浮内容，并插入到消息框上方\n     * @param {Element} messageElement 消息容器元素\n     */\n    function createFloatingContent(messageElement) {\n        // 先移除所有现有悬浮窗\n        removeAllFloatingContents();\n        const floatingContent = document.createElement('div');\n        floatingContent.className = 'ai-floating-content';\n        \n        // 定位逻辑：放在发送者区域顶部，向上扩展\n        let positionStyle = '';\n        \n                 // 根据消息方向调整左右对齐，并偏移以避免遮挡上一条消息\n         if (messageElement.classList.contains('msg-left')) {\n             // 用户消息，向右偏移\n             positionStyle = `\n                 position: absolute;\n                 bottom: 100%; /* 固定在容器底部，向上扩展 */\n                 margin-bottom: 2px; /* 与顶部保持一点距离 */\n                 left: 50px; /* 向右偏移，避免遮挡上一条消息 */\n                 right: auto;\n             `;\n         } else {\n             // 客服消息，向左偏移\n             positionStyle = `\n                 position: absolute;\n                 bottom: 100%; /* 固定在容器底部，向上扩展 */\n                 margin-bottom: 2px; /* 与顶部保持一点距离 */\n                 right: 50px; /* 向左偏移，避免遮挡上一条消息 */\n                 left: auto;\n             `;\n         }\n        \n        // 调试输出\n        if (PLUGIN_CONFIG.debug) {\n            pluginLog('设置悬浮窗在发送者区域顶部，向上扩展');\n        }\n        \n        floatingContent.style.cssText = `\n            ${positionStyle}\n            background: #ffffff;\n            border: 1px solid #e8e8e8;\n            border-radius: 6px;\n            padding: 8px 12px;\n            font-size: 12px;\n            cursor: pointer;\n            z-index: 1000;\n            max-width: 280px; /* 减小最大宽度，避免遮挡 */\n            min-width: 120px;\n            max-height: 150px;\n            overflow-y: auto;\n            box-shadow: 0 4px 12px rgba(0,0,0,0.15);\n            transition: all 0.2s ease;\n            word-wrap: break-word;\n            line-height: 1.4;\n            text-align: left;\n        `;\n        \n        // 初始显示加载状态\n        floatingContent.innerHTML = `\n            <div style=\"display: flex; align-items: center; gap: 8px;\">\n                <div style=\"width: 12px; height: 12px; border: 2px solid #f3f3f3; border-top: 2px solid #1890ff; border-radius: 50%; animation: spin 1s linear infinite;\"></div>\n                <span style=\"color: #666;\">正在查询...</span>\n            </div>\n            <style>\n                @keyframes spin {\n                    0% { transform: rotate(0deg); }\n                    100% { transform: rotate(360deg); }\n                }\n            </style>\n        `;\n        \n        // 鼠标悬停效果\n        floatingContent.addEventListener('mouseenter', () => {\n            floatingContent.style.transform = 'scale(1.02)';\n            floatingContent.style.boxShadow = '0 6px 16px rgba(0,0,0,0.2)';\n        });\n        floatingContent.addEventListener('mouseleave', () => {\n            floatingContent.style.transform = 'scale(1)';\n            floatingContent.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)';\n        });\n        \n        // 点击事件：点击后粘贴到输入框\n        floatingContent.addEventListener('click', (e) => {\n            e.stopPropagation();\n            // 优先使用保存的完整内容\n            const fullContent = floatingContent.getAttribute('data-full-content');\n            const content = fullContent || floatingContent.textContent.trim();\n            \n            if (content && content !== '正在查询...') {\n                // 检查是否以【XX】开头\n                const bracketMatch = content.match(/^【[^】]*】/);\n                if (bracketMatch) {\n                    // 获取消息信息用于API调用\n                    const messageInfo = extractMessageInfo(messageElement);\n                    pasteToInputBox(content, messageInfo, floatingContent);\n                    pluginLog('内容以标签开头，执行粘贴操作');\n                } else {\n                    pluginLog('内容不以标签开头，不执行粘贴操作');\n                }\n            }\n        });\n        \n        // 尝试找到发送者区域作为容器\n        let senderContainer = null;\n        \n        // 1. 首先尝试找到发送者姓名元素的父容器\n        const senderName = messageElement.querySelector(PLUGIN_CONFIG.messageSelectors.senderName);\n        if (senderName) {\n            senderContainer = senderName.parentElement;\n            pluginLog('找到发送者姓名元素');\n        }\n        \n        // 2. 如果找不到发送者姓名，尝试找消息头部区域\n        if (!senderContainer) {\n            senderContainer = messageElement.querySelector('.msg-header') || \n                             messageElement.querySelector('.msg-title');\n            if (senderContainer) {\n                pluginLog('找到消息头部区域');\n            }\n        }\n        \n        // 3. 如果上述都找不到，回退到消息主体\n        if (!senderContainer) {\n            senderContainer = messageElement.querySelector('.msg-main');\n            if (senderContainer) {\n                pluginLog('回退到消息主体');\n            }\n        }\n        \n        if (senderContainer) {\n            // 确保容器有position:relative\n            senderContainer.style.position = 'relative';\n            \n            // 悬浮内容添加到发送者容器\n            senderContainer.appendChild(floatingContent);\n            \n            // 确保悬浮窗可见\n            floatingContent.style.zIndex = '1000';\n            pluginLog('已添加悬浮窗到发送者区域');\n        } else {\n            pluginError('未找到合适的容器元素');\n        }\n        \n        // 提取消息信息并调用API\n        const messageInfo = extractMessageInfo(messageElement);\n        if (messageInfo) {\n            queryAPIAndUpdateContent(messageInfo, floatingContent);\n        }\n    }\n    \n    // 调用API查询并更新悬浮内容\n    async function queryAPIAndUpdateContent(messageInfo, floatingContent) {\n        try {\n            const apiUrl = `${PLUGIN_CONFIG.api.baseUrl}${PLUGIN_CONFIG.api.endpoint}`;\n            const response = await fetch(apiUrl, {\n                method: 'POST',\n                headers: {\n                    'Authorization': PLUGIN_CONFIG.api.token,\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    group_name: messageInfo.groupName,\n                    user_name: messageInfo.senderName,\n                    question: messageInfo.content,\n                    message_type: messageInfo.messageType,\n                    create_time: messageInfo.timestamp,\n                })\n            });\n            \n            if (!response.ok) {\n                pluginError(`HTTP error! status: ${response.status}`);\n                floatingContent.innerHTML = `\n                    <div style=\"color: #ff4d4f; font-size: 12px;\">\n                        系统异常，请稍后重试\n                    </div>\n                `;\n            }\n            \n            const data = await response.json();\n            let fullResult = '【高】' + (data.answer1 || '未能获取查询结果，请稍后重试');\n\n            // 将接口的\\n替换为<br>\n            fullResult = fullResult.replace(/\\n/g, '<br>');\n            \n            // 保存完整内容到悬浮元素的data属性中\n            floatingContent.setAttribute('data-full-content', fullResult);\n            \n            // 暂存API返回的关键参数，用于后续的点击使用量收集\n            floatingContent.setAttribute('data-api-id', data.id || '');\n            floatingContent.setAttribute('data-qiyu-channel', data.qiyu_channel || '');\n            floatingContent.setAttribute('data-qiyu-industry', data.qiyu_industry || '');\n\n            // 显示内容（截断版本）\n            let displayResult = fullResult;\n            if (displayResult.length > 100) {\n                displayResult = displayResult.substring(0, 100) + '...';\n            }\n            \n            // 更新悬浮内容\n            floatingContent.innerHTML = `\n                <div style=\"color: #333; font-size: 12px; line-height: 1.4; text-align: left;\">\n                    ${displayResult}\n                </div>\n            `;\n            \n            // 根据内容长度动态调整宽度，但限制最大宽度，避免遮挡\n            const textLength = displayResult.length;\n            if (textLength > 100) {\n                floatingContent.style.maxWidth = '280px';\n            } else if (textLength > 30) {\n                floatingContent.style.maxWidth = '300px';\n            } else {\n                floatingContent.style.maxWidth = '350px';\n            }\n            \n            pluginLog('API查询完成，结果已更新到悬浮内容');\n            \n        } catch (error) {\n            pluginError('API查询失败:', error);\n            \n            // 检查是否是混合内容错误\n            if (error.message.includes('Mixed Content') || error.message.includes('Failed to fetch')) {\n                floatingContent.innerHTML = `\n                    <div style=\"color: #ff4d4f; font-size: 12px;\">\n                        网络连接异常，请检查服务器配置\n                    </div>\n                `;\n            } else {\n                floatingContent.innerHTML = `\n                    <div style=\"color: #ff4d4f; font-size: 12px;\">\n                        系统异常，请稍后重试\n                    </div>\n                `;\n            }\n        }\n    }\n    \n    // 粘贴内容到输入框\n    function pasteToInputBox(content, messageInfo = null, floatingContent = null) {\n        try {\n            // 查找富文本输入框\n            const editor = document.querySelector('.ql-editor[contenteditable=\"true\"]');\n            if (editor) {\n                // 去掉开头的【XX】格式内容\n                let processedContent = content;\n                const bracketMatch = content.match(/^【[^】]*】/);\n                if (bracketMatch) {\n                    processedContent = content.substring(bracketMatch[0].length).trim();\n                    pluginLog('已去掉开头标签:', bracketMatch[0], '处理后的内容:', processedContent);\n                }\n                \n                // 将<br>标签转换为换行符，以便在富文本编辑器中正确显示\n                processedContent = processedContent.replace(/<br>/gi, '\\n');\n                \n                editor.innerHTML = processedContent;\n                // 触发输入事件，确保富文本框能感知内容变化\n                editor.dispatchEvent(new Event('input', { bubbles: true }));\n                pluginLog('已粘贴到输入框:', processedContent);\n\n                // 执行完粘贴操作后，调用API收集点击使用量\n                if (messageInfo && floatingContent) {\n                    const { groupName, senderName, content: question } = messageInfo;\n                    \n                    // 从floatingContent中获取暂存的API参数\n                    const apiId = floatingContent.getAttribute('data-api-id') || '';\n                    const qiyuChannel = floatingContent.getAttribute('data-qiyu-channel') || '';\n                    const qiyuIndustry = floatingContent.getAttribute('data-qiyu-industry') || '';\n                    \n                    collectClickUsage(groupName, senderName, question, content, apiId, qiyuChannel, qiyuIndustry);\n                    pluginLog('已调用API收集点击使用量');\n                }\n            } else {\n                pluginError('未找到富文本输入框');\n            }\n        } catch (error) {\n            pluginError('粘贴到输入框时出错:', error);\n        }\n    }\n    \n    // 新增：格式化时间戳，补全年份\n    function formatTimestamp(timeStr) {\n        if (!timeStr) return null;\n\n        const now = new Date();\n        \n        // 新增：匹配 \"今天 HH:mm\" 或 \"今天 HH:mm:ss\"\n        const todayMatch = timeStr.match(/^今天\\s*(\\d{1,2}):(\\d{2})(?::(\\d{2}))?$/);\n        if (todayMatch) {\n            const date = new Date(now);\n            const hours = parseInt(todayMatch[1], 10);\n            const minutes = parseInt(todayMatch[2], 10);\n            const seconds = todayMatch[3] ? parseInt(todayMatch[3], 10) : 0;\n            return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;\n        }\n\n        // 匹配 \"昨天 HH:mm\" 或 \"昨天 HH:mm:ss\"\n        const yesterdayMatch = timeStr.match(/^昨天\\s*(\\d{1,2}):(\\d{2})(?::(\\d{2}))?$/);\n        if (yesterdayMatch) {\n            const date = new Date(now.getTime() - 24 * 60 * 60 * 1000);\n            const hours = parseInt(yesterdayMatch[1], 10);\n            const minutes = parseInt(yesterdayMatch[2], 10);\n            const seconds = yesterdayMatch[3] ? parseInt(yesterdayMatch[3], 10) : 0;\n            return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;\n        }\n        \n        // 匹配 \"MM-DD HH:mm\" 或 \"MM-DD HH:mm:ss\"\n        const monthDayMatch = timeStr.match(/^(\\d{2})-(\\d{2})\\s*(\\d{1,2}):(\\d{2})(?::(\\d{2}))?$/);\n        if (monthDayMatch) {\n            let year = now.getFullYear();\n            const month = parseInt(monthDayMatch[1], 10) - 1;\n            const day = parseInt(monthDayMatch[2], 10);\n\n            // 如果日期在未来，则为去年\n            const tempDate = new Date(year, month, day, 23, 59, 59);\n            if (tempDate > now) {\n                year--;\n            }\n            const hours = parseInt(monthDayMatch[3], 10);\n            const minutes = parseInt(monthDayMatch[4], 10);\n            const seconds = monthDayMatch[5] ? parseInt(monthDayMatch[5], 10) : 0;\n            return `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')} ${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;\n        }\n        \n        // 匹配 \"HH:mm\" 或 \"HH:mm:ss\" (今天)\n        const timeOnlyMatch = timeStr.match(/^(\\d{1,2}):(\\d{2})(?::(\\d{2}))?$/);\n        if (timeOnlyMatch) {\n            const date = new Date(now);\n            const hours = parseInt(timeOnlyMatch[1], 10);\n            const minutes = parseInt(timeOnlyMatch[2], 10);\n            const seconds = timeOnlyMatch[3] ? parseInt(timeOnlyMatch[3], 10) : 0;\n            return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;\n        }\n\n        // 如果已经是 \"YYYY-MM-DD HH:mm:ss\" 格式，直接返回\n        if (/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/.test(timeStr)) {\n            return timeStr;\n        }\n\n        // 无法识别，返回原始值\n        pluginWarn('无法解析时间格式:', timeStr);\n        return timeStr;\n    }\n    \n    // 提取消息信息\n    function extractMessageInfo(messageElement) {\n        try {\n            // 获取群聊名称（在页面顶部的聊天信息中）\n            const groupNameElement = document.querySelector(PLUGIN_CONFIG.messageSelectors.groupName);\n            const groupName = groupNameElement ? \n                groupNameElement.textContent.trim() : \n                '未知群聊';\n            \n            // 获取发送人信息（优先从消息元素内部查找）\n            let senderName = '未知用户';\n            const senderElement = messageElement.querySelector(PLUGIN_CONFIG.messageSelectors.senderName);\n            if (senderElement) {\n                senderName = senderElement.textContent.trim();\n            } else {\n                // 如果是系统消息或右侧消息，可能没有发送人名称\n                if (messageElement.classList.contains('msg-sys')) {\n                    senderName = '系统';\n                } else if (messageElement.classList.contains('msg-right')) {\n                    senderName = '客服';\n                } else if (messageElement.classList.contains('msg-left')) {\n                    senderName = '用户';\n                }\n            }\n\n            // 判断消息类型（图片 or 文字）\n            let messageContent = '';\n            let messageType = 'text';\n            // 检查是否为图片消息\n            const imageElement = messageElement.querySelector('img.m-message-image_pic');\n            if (imageElement && imageElement.src) {\n                messageContent = imageElement.src;\n                messageType = 'image';\n            } else {\n                // 文字消息逻辑\n                const contentElement = messageElement.querySelector(PLUGIN_CONFIG.messageSelectors.messageContent);\n                if (contentElement) {\n                    messageContent = contentElement.textContent.trim();\n                } else {\n                    // 如果没有找到指定的内容元素，尝试其他方式\n                    const msgBubble = messageElement.querySelector('.msg-bubble');\n                    if (msgBubble) {\n                        // 移除时间元素后获取内容\n                        const timeElement = msgBubble.querySelector('.time');\n                        let bubbleText = msgBubble.textContent.trim();\n                        if (timeElement) {\n                            bubbleText = bubbleText.replace(timeElement.textContent.trim(), '').trim();\n                        }\n                        messageContent = bubbleText;\n                    }\n                }\n            }\n\n            // 获取消息时间\n            let rawTimestamp = null;\n            const timeElement = messageElement.querySelector(PLUGIN_CONFIG.messageSelectors.messageTime);\n            if (timeElement) {\n                rawTimestamp = timeElement.textContent.trim();\n            }\n            const timestamp = formatTimestamp(rawTimestamp);\n            \n            // 获取消息方向\n            const direction = messageElement.classList.contains('msg-sys') ? 'system' :\n                              messageElement.classList.contains('msg-right') ? 'sent' : 'received';\n            \n            return {\n                content: messageContent,\n                senderName,\n                groupName,\n                timestamp,\n                direction, // 原messageType改为direction\n                messageType, // 原messageContentType改为messageType\n                url: window.location.href\n            };\n        } catch (error) {\n            pluginError('提取消息信息时出错:', error);\n            return null;\n        }\n    }\n    \n    // === 激活/失活机制集成 ===\n    let pluginActive = false;\n    let urlCheckTimer = null;\n\n    function activatePluginIfNeeded() {\n        if (shouldActivatePlugin()) {\n            if (!pluginActive) {\n                initPlugin();\n                pluginActive = true;\n                pluginLog('已激活');\n            }\n        } else {\n            if (pluginActive) {\n                destroyPlugin();\n                pluginActive = false;\n                pluginLog('已失活');\n            }\n        }\n    }\n\n    // 失活时移除所有事件监听、定时器等\n    function destroyPlugin() {\n        // 1. 移除消息悬停监听\n        if (onMessageClickHandler) {\n            document.removeEventListener('mouseenter', onMessageClickHandler.handleMouseEnter, true);\n            document.removeEventListener('mouseleave', onMessageClickHandler.handleMouseLeave, true);\n            \n            // 移除聊天容器的监听器\n            const chatContainer = document.querySelector('#chat-view');\n            if (chatContainer) {\n                chatContainer.removeEventListener('mouseenter', onMessageClickHandler.handleMouseEnter, true);\n                chatContainer.removeEventListener('mouseleave', onMessageClickHandler.handleMouseLeave, true);\n            }\n            \n            onMessageClickHandler = null;\n            pluginLog('已移除消息悬停监听');\n        }\n        \n        // 2. 清理所有悬浮内容\n        const floatingContents = document.querySelectorAll('.ai-floating-content');\n        floatingContents.forEach(content => content.remove());\n        \n        // 注意：不清理URL定时器，保持URL监听器持续运行\n        // 3. 重置激活状态\n        pluginActive = false;\n    }\n\n    // 监听URL变化\n    let lastUrl = location.href;\n    // 只在没有定时器时才创建新的定时器\n    if (!urlCheckTimer) {\n        urlCheckTimer = setInterval(() => {\n            if (location.href !== lastUrl) {\n                lastUrl = location.href;\n                activatePluginIfNeeded();\n            }\n        }, 500);\n        pluginLog('已创建URL监听器');\n    }\n\n    // API调用函数：收集点击使用量\n    async function collectClickUsage(groupName, userName, question, answer, apiId, qiyuChannel, qiyuIndustry) {\n        try {\n            const apiUrl = PLUGIN_CONFIG.api.baseUrl + PLUGIN_CONFIG.api.clickUsageEndpoint;\n            const requestData = {\n                group_name: groupName || '', // 群名\n                user_name: userName || '', // 发送者\n                question: question || '', // 问题\n                answer: answer || '', // 答案\n                id: apiId || '', // API返回的id\n                qiyu_channel: qiyuChannel || '', // 七鱼渠道\n                qiyu_industry: qiyuIndustry || '' // 七鱼行业\n            };\n            pluginLog('点击使用量收集，请求参数:', requestData);\n\n            const response = await fetch(apiUrl, {\n                method: 'POST',\n                headers: {\n                    'Authorization': PLUGIN_CONFIG.api.token,\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify(requestData)\n            });\n            pluginLog('点击使用量收集，响应:', response);\n\n            if (response.ok) {\n                const result = await response.json();\n                pluginLog('点击使用量收集成功:', result);\n            } else {\n                pluginError('点击使用量收集失败:', response.status, response.statusText);\n            }\n        } catch (error) {\n            pluginError('API调用出错:', error);\n        }\n    }\n\n    // 页面初始也要判断一次\n    activatePluginIfNeeded();\n    \n})(); ","isHtml":false,"htmlPath":"","htmlFiles":[],"more":{"windows":{"label":"","title":"","url":"https://ybzfyxgs5.qiyukf.com/chat/","userAgent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36","width":1920,"height":1080,"theme":null,"resizable":true,"fullscreen":false,"maximized":false,"minWidth":400,"minHeight":300,"maxWidth":1920,"maxHeight":1080,"decorations":true,"transparent":false,"titleBarStyle":"Visible","visible":true,"focus":true,"closable":true,"minimizable":true,"maximizable":true,"alwaysOnTop":false,"alwaysOnBottom":false,"center":false,"skipTaskbar":false,"tabbingIdentifier":null,"parent":null,"dragDropEnabled":true,"browserExtensionsEnabled":false,"devtools":true,"contentProtected":false,"hiddenTitle":false,"incognito":false,"proxyUrl":null,"useHttpsScheme":false,"zoomHotkeysEnabled":false,"acceptFirstMouse":false,"create":false}},"phone":{"safeArea":{"top":0,"bottom":0,"left":0,"right":0},"header":{"show":false,"title":"","backgroundColor":"","color":"","fontSize":16,"fontWeight":"bold","loading":false,"toolBar":false,"toolBarBackgroundColor":"","toolBarColor":"","toolBarFontSize":16,"toolBarFontWeight":"bold"},"siderMenu":{"show":false,"width":0,"backgroundColor":"","color":"","fontSize":16,"fontWeight":"bold","title":"","titleColor":"","titleFontSize":16,"titleFontWeight":"bold"},"tabBar":{"show":false,"backgroundColor":"","color":"","activeColor":"","fontSize":16,"fontWeight":"bold","tabBarItem":[]},"webview":{"userAgent":"","javaScriptEnabled":true,"domStorageEnabled":true,"allowFileAccess":true,"loadWithOverviewMode":true,"setSupportZoom":true,"clearCache":true}},"ios":{"name":"Qiyukf","showName":"Qiyukf","version":"0.0.1","webUrl":"https://ybzfyxgs5.qiyukf.com/chat/","id":"com.Qiyukf.app.ios","icon":"./app-icon.png","desc":"Package for personal use only, please do not use for commercial purposes（打包仅限个人使用，请勿传播或商业用途）","pubBody":"Package for personal use only, please do not use for commercial purposes（打包仅限个人使用，请勿传播或商业用途）","isHtml":false,"debug":false},"android":{"name":"Qiyukf","showName":"Qiyukf","version":"0.0.1","webUrl":"https://ybzfyxgs5.qiyukf.com/chat/","id":"com.Qiyukf.app.android","icon":"./app-icon.png","input":"./app-icon.png","output":"./res","rounded":true,"copyTo":"./app/src/main/res","androidResDir":"./app/src/main/res","desc":"Package for personal use only, please do not use for commercial purposes（打包仅限个人使用，请勿传播或商业用途）","pubBody":"Package for personal use only, please do not use for commercial purposes（打包仅限个人使用，请勿传播或商业用途）","isHtml":false,"debug":false},"desktop":{"name":"Qiyukf","showName":"Qiyukf","version":"0.0.1","id":"com.Qiyukf.app.desktop","desc":"Package for personal use only, please do not use for commercial purposes（打包仅限个人使用，请勿传播或商业用途，否则后果自负）","webUrl":"https://ybzfyxgs5.qiyukf.com/chat/","iconPath":"../app-icon.png","inputPath":"../app-icon.png","tempPath":"./processed-image.png","icnsPath":"../src-tauri/icons/icon.icns","pubBody":"Package for personal use only, please do not use for commercial purposes（打包仅限个人使用，请勿传播或商业用途，否则后果自负）","isHtml":false,"single":true,"state":true,"injectJq":false,"tauriApi":false,"buildMethod":"cloud","debug":true}}